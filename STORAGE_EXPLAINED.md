# ZW101 指纹存储机制详解

## 🔍 指纹存储位置

### 答案: 存储在 **ZW101 指纹模组内部的 Flash 存储器**

ZW101 指纹模组是一个**独立的智能硬件**,内部集成了:
- 📷 光学传感器 (采集指纹图像)
- 🧠 处理器 (特征提取和比对)
- 💾 **Flash 存储器** (存储指纹模板)

```
┌─────────────────────────────┐
│   ZW101 指纹识别模组         │
│                             │
│  ┌──────────────────────┐  │
│  │  光学传感器          │  │ ← 采集指纹图像
│  └──────────────────────┘  │
│           ↓                 │
│  ┌──────────────────────┐  │
│  │  处理器 (MCU)        │  │ ← 提取特征值
│  │  - AS608/R30x芯片    │  │
│  └──────────────────────┘  │
│           ↓                 │
│  ┌──────────────────────┐  │
│  │  Flash 存储器        │  │ ← **指纹存储在这里!**
│  │  - 容量: 200枚       │  │
│  │  - 断电不丢失        │  │
│  └──────────────────────┘  │
│                             │
│  UART 通信接口 ──→ ESP32   │
└─────────────────────────────┘
```

## 💾 存储详细信息

### 1. 存储位置
- **物理位置**: ZW101 模组内部 Flash 芯片
- **存储内容**: 指纹特征模板 (不是原始图像!)
- **容量**: 通常 200 枚指纹 (可能因型号不同)
- **特点**: 断电后数据保存,永久存储

### 2. 存储的是什么?

**不是存储指纹图像!** ❌

ZW101 存储的是**指纹特征模板** (Fingerprint Template):

```
原始指纹图像 (256x288 像素)
    ↓ 特征提取算法
指纹特征点 (细节点、分叉点、端点等)
    ↓ 压缩编码
特征模板 (约 512-1024 字节)  ← 这个被存储!
```

**为什么不存原始图像?**
- 原始图像太大 (~73KB)
- 特征模板很小 (~512B-1KB)
- 比对速度更快
- 更安全 (无法还原原图)

### 3. 存储结构

ZW101 内部使用**指纹库 (Fingerprint Library)** 管理:

```
Flash 存储器布局:
┌────────────────────────────┐
│  ID 0: 指纹模板 0          │ ← 512-1024 字节
├────────────────────────────┤
│  ID 1: 指纹模板 1          │
├────────────────────────────┤
│  ID 2: 指纹模板 2          │
├────────────────────────────┤
│  ...                       │
├────────────────────────────┤
│  ID 199: 指纹模板 199      │
└────────────────────────────┘
总容量: 约 100-200KB
```

**索引表**:
ZW101 还维护一个索引表 (Index Table),记录哪些 ID 已被使用:

```
索引表 (32 字节 = 256 位)
┌─┬─┬─┬─┬─┬─┬─┬─┐
│1│0│1│1│0│0│0│1│ ← 每 1 位代表一个 ID
└─┴─┴─┴─┴─┴─┴─┴─┘
  ↑       ↑
  已使用  空闲

读取索引表命令: 0x1F (CMD_READ_INDEX_TABLE)
```

## 🔄 存储流程

### 注册指纹时的完整流程:

```cpp
1. ESP32 发送命令: 采集图像 (0x01)
   → ZW101: 采集指纹图像到内部 RAM

2. ESP32 发送命令: 生成特征 (0x02)
   → ZW101: 从图像提取特征 → 存入 CharBuffer1

3. 重复 1-2 共 5 次
   → ZW101: 5 个特征存入 CharBuffer1-5

4. ESP32 发送命令: 合并特征 (0x05)
   → ZW101: 合并 5 个特征 → 生成最终模板

5. ESP32 发送命令: 存储模板 (0x06, buffer_id, page_id)
   → ZW101: 将模板写入 Flash 的 page_id 位置 ✅

// 代码示例
send_cmd(CMD_GET_IMAGE);          // 步骤1
send_cmd2(CMD_GEN_CHAR, 1);       // 步骤2
// ... 重复5次
send_cmd(CMD_REG_MODEL);          // 步骤4
send_store_cmd(1, page_id);       // 步骤5 - 存入Flash!
```

### 验证指纹时的流程:

```cpp
1. ESP32 发送: 采集图像
   → ZW101: 采集图像到 RAM

2. ESP32 发送: 生成特征 (buffer=1)
   → ZW101: 提取特征到 CharBuffer1

3. ESP32 发送: 搜索指纹库 (0x04, start_id=0, count=200)
   → ZW101:
      - 从 Flash 读取 ID 0-199 的模板
      - 与 CharBuffer1 逐个比对
      - 找到匹配 → 返回 ID 和得分 ✅

// 代码示例
send_cmd(CMD_GET_IMAGE);
send_cmd2(CMD_GEN_CHAR, 1);
send_search_cmd(1, 0, 200);  // 搜索整个Flash库
```

## 📊 存储容量详情

根据 `fp_syno_protocol.c` 和 `ZW101.ino`:

```cpp
// 从 fp_syno_protocol.h
#define FP_SYNO_SUPPORT_ENROLL_NUMS  200  // 最大200枚

// 从 read_fp_info() 读取的参数:
uint16_t fp_lib_size = (response[14] << 8) | response[15];
// 指纹库大小: 通常 200
```

**实际容量**:
- 最大指纹数量: **200 枚**
- 每枚模板大小: **约 512-1024 字节**
- 总 Flash 空间: **约 100-200 KB**

## 🔐 数据安全

### 1. 数据持久性
- ✅ **断电不丢失** - 存储在 Flash
- ✅ **长期保存** - Flash 寿命 10 万次擦写
- ✅ **独立存储** - 不依赖 ESP32

### 2. 隐私保护
- ✅ **无法还原原图** - 只存特征值
- ✅ **芯片加密** - 无法直接读取 Flash
- ✅ **本地存储** - 不上传云端

### 3. 数据安全风险

⚠️ **注意**:
- 如果模组被物理盗取,指纹数据可能被读取
- 建议配合密码或其他认证方式
- 重要场合建议定期更换指纹

## 💡 常见问题

### Q1: ESP32 重启后指纹还在吗?
**A**: ✅ **在!** 指纹存储在 ZW101 模组内部 Flash,与 ESP32 无关。

### Q2: ZW101 断电后指纹丢失吗?
**A**: ✅ **不会!** Flash 存储器断电不丢失,永久保存。

### Q3: 可以备份指纹数据吗?
**A**: ⚠️ **理论可以,但不推荐**
- 可以通过 UART 读取模板数据
- 需要专用命令 (本组件未实现)
- 安全风险较高
- 更推荐记录指纹 ID 和用户信息的对应关系

### Q4: 删除指纹后 Flash 空间释放吗?
**A**: ✅ **是的!**
```cpp
delete_fingerprint(5);  // 删除 ID 5
// ZW101 内部:
// 1. 清除 Flash 中 ID 5 的模板数据
// 2. 更新索引表标记 ID 5 为空闲
// 3. 空间可被重新使用
```

### Q5: 200 枚指纹够用吗?
**A**:
- **家庭使用**: 够用 (一般 5-10 人)
- **小型公司**: 够用 (50-100 人)
- **大型企业**: 不够,需要企业级设备

### Q6: 可以在 ESP32 上存储指纹吗?
**A**: ❌ **不推荐!**
- ZW101 已经有专用 Flash
- ESP32 存储不安全
- 比对算法在 ZW101 芯片内
- 无法在 ESP32 上进行比对

### Q7: 如何查看已存储的指纹 ID?
**A**: 使用读取索引表功能:
```cpp
// 本组件可以实现 (目前未添加)
void read_index_table() {
  send_cmd_with_param(CMD_READ_INDEX_TABLE, 0);
  // 返回 32 字节位图,每位代表一个 ID
}

// 或者使用更简单的方法:
read_valid_template_count();  // 返回已注册数量
```

## 🛠️ 扩展功能 (未来可添加)

### 1. 导出指纹模板
```cpp
// 命令码: 0x07 (Upload Template)
bool upload_template(uint16_t id, uint8_t *buffer, size_t *len) {
  send_cmd3(0x07, 1, id);  // 从Flash读到CharBuffer
  // ... 接收模板数据
}
```

### 2. 导入指纹模板
```cpp
// 命令码: 0x08 (Download Template)
bool download_template(uint16_t id, uint8_t *data, size_t len) {
  send_cmd3(0x08, 1, id);
  // ... 发送模板数据到CharBuffer
  send_store_cmd(1, id);   // 保存到Flash
}
```

### 3. 读取完整索引表
```cpp
bool read_all_enrolled_ids(std::vector<uint16_t> &ids) {
  send_cmd2(CMD_READ_INDEX_TABLE, 0);
  uint8_t index_table[32];
  // ... 解析位图获取所有ID
}
```

## 📝 总结

### 指纹存储位置: **ZW101 模组内部 Flash**

| 项目 | 详情 |
|------|------|
| 存储位置 | ZW101 内部 Flash 芯片 |
| 存储内容 | 指纹特征模板 (非原图) |
| 容量 | 200 枚指纹 |
| 每枚大小 | 约 512-1024 字节 |
| 断电保存 | ✅ 是 |
| 依赖 ESP32 | ❌ 否,完全独立 |
| 可以备份 | ⚠️ 理论可以,不推荐 |
| 可以导出 | ⚠️ 需要专用命令 |
| 隐私安全 | ✅ 无法还原原图 |

### 工作流程:
```
注册: 采图 → 提取特征 → 合并 → 存入Flash ✅
验证: 采图 → 提取特征 → 从Flash读库 → 比对 ✅
删除: 清除Flash数据 → 更新索引表 ✅
```

### ESP32 的作用:
- 📡 **通信桥梁** - 通过 UART 发送命令
- 🎛️ **控制中心** - 控制指纹流程
- 📊 **数据展示** - 显示匹配结果
- 🏠 **智能集成** - 接入 Home Assistant

**ESP32 不存储指纹,只是控制器!**

所有指纹数据安全地存储在 ZW101 模组内部 Flash 中。
